import { ComponentFixture, TestBed } from '@angular/core/testing';
import { DatasetEditComponent } from './dataset-edit.component';
import { DatasetInfoService } from 'src/app/services/common-storage/dataset-info.service';
import { UploadService } from 'src/app/services/http/upload/service.service';
import { AuthentificationService } from 'src/app/authentication/authentication.service';
import { of, throwError } from 'rxjs';
import { NO_ERRORS_SCHEMA } from '@angular/core';

describe('DatasetEditComponent', () => {
  let component: DatasetEditComponent;
  let fixture: ComponentFixture<DatasetEditComponent>;
  let mockDatasetInfoService: jasmine.SpyObj<DatasetInfoService>;
  let mockUploadService: jasmine.SpyObj<UploadService>;
  let mockAuthentificationService: jasmine.SpyObj<AuthentificationService>;

  beforeEach(() => {
    mockDatasetInfoService = jasmine.createSpyObj('DatasetInfoService', [
      'currentReferentialId',
      'currentUserName',
      'currentDatasetContent',
      'currentDatasetVersions',
      'currentSelectedVersion',
      'getCSVFileDefinitionFromGridDataWithHeader',
      'getDatasetContent',
      'sendDataToLucid'
    ]);

    mockUploadService = jasmine.createSpyObj('UploadService', [
      'getCSVFileDefinitionFromGridDataWithHeader',
      'sendDataToLucid',
      'mapHttpResponseToDataset'
    ]);

    mockAuthentificationService = jasmine.createSpyObj('AuthentificationService', ['fetchUserName']);

    TestBed.configureTestingModule({
      declarations: [DatasetEditComponent],
      providers: [
        { provide: DatasetInfoService, useValue: mockDatasetInfoService },
        { provide: UploadService, useValue: mockUploadService },
        { provide: AuthentificationService, useValue: mockAuthentificationService }
      ],
      schemas: [NO_ERRORS_SCHEMA]
    }).compileComponents();

    fixture = TestBed.createComponent(DatasetEditComponent);
    component = fixture.componentInstance;
  });

  it('should create the component and initialize data', () => {
    // Arrange
    mockDatasetInfoService.currentReferentialId.and.returnValue(of('testReferentialId'));
    mockDatasetInfoService.currentUserName.and.returnValue(of('testUserName'));
    mockDatasetInfoService.currentDatasetContent.and.returnValue(of([]));
    mockDatasetInfoService.currentDatasetVersions.and.returnValue(of([]));
    mockDatasetInfoService.currentSelectedVersion.and.returnValue(of('testVersion'));

    // Act
    component.ngOnInit();

    // Assert
    expect(mockDatasetInfoService.currentReferentialId).toHaveBeenCalled();
    expect(mockDatasetInfoService.currentUserName).toHaveBeenCalled();
    expect(mockDatasetInfoService.currentDatasetContent).toHaveBeenCalled();
    expect(mockDatasetInfoService.currentDatasetVersions).toHaveBeenCalled();
    expect(mockDatasetInfoService.currentSelectedVersion).toHaveBeenCalled();
    expect(component.version).toBe('testVersion');
  });

  it('should call fetchUserName and set userName on initialization', () => {
    // Arrange
    mockAuthentificationService.fetchUserName.and.returnValue('testUser');
    
    // Act
    component.ngOnInit();
    
    // Assert
    expect(mockAuthentificationService.fetchUserName).toHaveBeenCalled();
    expect(component.userName).toBe('testUser');
  });

  it('should handle empty dataset case in pushToLucid', () => {
    // Arrange
    component.datasetContent = [];
    spyOn(component.datalsValid, 'emit');

    // Act
    component.pushToLucid();

    // Assert
    expect(component.alertValue.message).toBe('Dataset is empty, please add data');
    expect(component.datalsValid.emit).toHaveBeenCalledWith(false);
  });

  it('should set alertValue to success and emit isPushed on successful pushToLucid', () => {
    // Arrange
    const mockResponse = new HttpResponse({ status: 200 });
    const datasetContentMock = [{ data: 'mockData' }];
    component.datasetContent = datasetContentMock;
    component.rowData = datasetContentMock;

    mockUploadService.sendDataToLucid.and.returnValue(of(mockResponse));
    spyOn(component.isPushed, 'emit');

    // Act
    component.pushToLucid();

    // Assert
    expect(component.showSpinner).toBe(false);
    expect(component.alertValue.message).toBe('Dataset has been pushed to Lucid successfully!');
    expect(component.isPushed.emit).toHaveBeenCalledWith(true);
  });

  it('should set alertValue to error on pushToLucid failure', () => {
    // Arrange
    const errorResponse = new HttpResponse({ status: 500 });
    const datasetContentMock = [{ data: 'mockData' }];
    component.datasetContent = datasetContentMock;
    component.rowData = datasetContentMock;

    mockUploadService.sendDataToLucid.and.returnValue(throwError(errorResponse));
    spyOn(component.isPushed, 'emit');

    // Act
    component.pushToLucid();

    // Assert
    expect(component.showSpinner).toBe(false);
    expect(component.alertValue.message).toBe("An error occurred during the transfer. Please try again later. You should export as CSV or save as a draft to not lose the modifications!");
    expect(component.isPushed.emit).toHaveBeenCalledWith(false);
  });

  it('should call addRowDataset when addRowDataset is called', () => {
    // Arrange
    const datasetComponent = {
      addRowDataset: jasmine.createSpy('addRowDataset')
    };
    component.datasetEditComponent = datasetComponent as any;

    // Act
    component.addRowDataset();

    // Assert
    expect(datasetComponent.addRowDataset).toHaveBeenCalled();
  });

  it('should emit editChangeOnVersion event on version change', () => {
    // Arrange
    spyOn(component.editChangeOnVersion, 'emit');
    const mockEvent = { target: { value: '1.0' } };

    // Act
    component.onVersionSelect(mockEvent);

    // Assert
    expect(component.editChangeOnVersion.emit).toHaveBeenCalledWith('1.0');
  });

  it('should update columnDefs when referentialId changes', () => {
    // Arrange
    mockDatasetInfoService.currentReferentialId.and.returnValue(of('newReferentialId'));
    spyOn(component, 'getColDefByReferentialId').and.returnValue([]);

    // Act
    component.ngOnInit();
    fixture.detectChanges();

    // Assert
    expect(component.getColDefByReferentialId).toHaveBeenCalledWith('newReferentialId');
    expect(component.columnDefs).toEqual([]);
  });

  // Add more test cases for other methods and scenarios as needed...
});
