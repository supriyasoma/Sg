it('should have correct referentialsColDef configuration', () => {
    const colDefs = referentials.referentialsColDef.find(col => col.id === 'business_area')?.colDef;

    expect(colDefs).toBeTruthy();

    const checkboxColDef: ColDef = colDefs?.[0];
    expect(checkboxColDef).toEqual({
      field: 'checkboxBtn',
      headerName: '',
      checkboxSelection: true,
      headerCheckboxSelection: true,
      pinned: 'left',
      minWidth: 50,
      maxWidth: 60
    });

    const sourceAppCodeColDef: ColDef = colDefs?.[1];
    expect(sourceAppCodeColDef).toEqual(jasmine.objectContaining({
      field: 'sourceApplicationCode',
      headerName: 'SourceApplicationCode',
      headerTooltip: 'SourceApplicationCode',
      floatingFilter: true,
      filter: 'agTextColumnFilter',
      suppressMenu: true,
      editable: false,
      resizable: true,
      sortable: true,
      cellClass: jasmine.any(Function),
      onCellValueChanged: jasmine.any(Function)
    }));

    const checkResultColDef: ColDef = colDefs?.[2];
    expect(checkResultColDef).toEqual(jasmine.objectContaining({
      field: 'checkResult',
      headerName: 'CheckResult',
      floatingFilter: true,
      filter: 'agTextColumnFilter',
      filterParams: jasmine.objectContaining({
        textMatcher: jasmine.any(Function)
      }),
      floatingFilterComponent: CheckResultFilterComponent,
      floatingFilterComponentParams: jasmine.objectContaining({
        suppressFilterButton: true
      }),
      suppressMenu: true,
      minWidth: 150,
      resizable: true,
      cellRendererSelector: jasmine.any(Function)
    }));
  });

  it('should have correct textMatcher function in filterParams', () => {
    const colDef = referentials.referentialsColDef.find(col => col.id === 'business_area')?.colDef[2];
    const textMatcher = colDef?.filterParams?.textMatcher;
    const mockData = { checkResult: { isValid: true, message: 'Test message' } };

    expect(textMatcher).toBeDefined();
    if (textMatcher) {
      expect(textMatcher('contains', 'Test', mockData)).toBe(true);
      expect(textMatcher('contains', 'Test', { checkResult: { isValid: false } })).toBe(false);
      expect(textMatcher('contains', '', { checkResult: { isValid: true } })).toBe(false);
    }
  });

  it('should call CheckResultRenderer with correct params in cellRendererSelector', () => {
    const colDef = referentials.referentialsColDef.find(col => col.id === 'business_area')?.colDef[2];
    const mockParams = { data: { checkResult: { isValid: true, message: 'Valid message' } } };

    const rendererResult = colDef?.cellRendererSelector(mockParams);
    expect(rendererResult).toBeDefined();
    if (rendererResult) {
      expect(rendererResult.component).toBe(CheckResultRenderer);
      expect(rendererResult.params.value).toEqual([true, 'Valid message']);
    }
  });
