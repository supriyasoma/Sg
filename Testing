import { of, throwError } from 'rxjs';
import { YourComponent } from './your.component';
import { MenuService } from '../services/menu.service';
import { AuthentificationService } from '../services/authentification.service';
import { SortUtil } from '../utils/sort-util';
import { MenuItem } from '../models/menu-item.model';

describe('YourComponent', () => {
  let component: YourComponent;
  let menuServiceMock: any;
  let authServiceMock: any;

  beforeEach(() => {
    menuServiceMock = jasmine.createSpyObj('MenuService', ['get']);
    authServiceMock = jasmine.createSpyObj('AuthentificationService', ['fetchUserinfo', 'hasUserPermission', 'fetchUserName']);
    component = new YourComponent(menuServiceMock, authServiceMock);
  });

  it('should retrieve menu items and sort them correctly', () => {
    const mockMenuItems = [
      { label: 'home' },
      { label: 'Application Reports', children: [] },
      { label: 'Regulatory reporting', children: [] },
    ];

    spyOn(SortUtil, 'sortByOrder').and.returnValue(mockMenuItems);
    menuServiceMock.get.and.returnValue(of(mockMenuItems));

    component.ngOnInit();

    expect(menuServiceMock.get).toHaveBeenCalled();
    expect(SortUtil.sortByOrder).toHaveBeenCalledWith(mockMenuItems);
  });

  it('should populate menu items based on user permissions', () => {
    const mockMenuItems = [
      { label: 'home' },
      { label: 'Application Reports', children: [{ label: 'Cobalt Volume RESO' }] },
      { label: 'Regulatory reporting', children: [] },
    ];

    const mockUserInfo = { isSgGroupUser: true };

    menuServiceMock.get.and.returnValue(of(mockMenuItems));
    authServiceMock.fetchUserinfo.and.returnValue(of(mockUserInfo));
    authServiceMock.hasUserPermission.and.callFake((userInfo, permission) => permission === 'api.bdf-bigban.volumereso.read.all');

    component.ngOnInit();

    expect(authServiceMock.hasUserPermission).toHaveBeenCalledWith(mockUserInfo, 'api.bdf-bigban.volumereso.read.all');
    expect(component.menuItems.length).toBeGreaterThan(0);
    expect(component.menuItems[1].children.length).toBe(1);
  });

  it('should handle error during menu retrieval', () => {
    spyOn(console, 'error');
    menuServiceMock.get.and.returnValue(throwError('Menu retrieval error'));

    component.ngOnInit();

    expect(console.error).toHaveBeenCalledWith('Error while retrieving Menu', 'Menu retrieval error');
  });

  it('should handle error during user info retrieval', () => {
    spyOn(console, 'error');
    const mockMenuItems = [{ label: 'home' }];

    menuServiceMock.get.and.returnValue(of(mockMenuItems));
    authServiceMock.fetchUserinfo.and.returnValue(throwError('User info error'));

    component.ngOnInit();

    expect(console.error).toHaveBeenCalledWith('Error while retrieving User Permission', 'User info error');
  });

  it('should set final menu items based on permissions and children count', () => {
    const mockMenuItems = [
      { label: 'home' },
      { label: 'Application Reports', children: [{ label: 'Cobalt Volume RESO' }] },
      { label: 'Regulatory reporting', children: [] },
    ];

    const mockUserInfo = { isSgGroupUser: true };

    menuServiceMock.get.and.returnValue(of(mockMenuItems));
    authServiceMock.fetchUserinfo.and.returnValue(of(mockUserInfo));
    authServiceMock.hasUserPermission.and.callFake((userInfo, permission) => permission.includes('read.all'));

    component.ngOnInit();

    expect(component.menuItems).toEqual([
      { label: 'home' },
      { label: 'Application Reports', children: [{ label: 'Cobalt Volume RESO' }] },
    ]);
  });
});
