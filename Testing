import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ReactiveFormsModule, FormBuilder } from '@angular/forms';
import { of, throwError } from 'rxjs';
import { AuthentificationService } from '../authentication/authentification-service';
import { DatasetInfoService } from '../services/common-storage/dataset-info-service';
import { InformationService } from './information-tab.service';
import { InformationTabComponent } from './information-tab.component';

describe('InformationTabComponent', () => {
  let component: InformationTabComponent;
  let fixture: ComponentFixture<InformationTabComponent>;

  let mockFormBuilder: any;
  let mockDatasetInfoService: any;
  let mockAuthentificationService: any;
  let mockInformationService: any;

  beforeEach(async () => {
    mockFormBuilder = jasmine.createSpyObj('FormBuilder', ['group', 'control']);
    mockFormBuilder.group.and.returnValue({
      value: {},
      controls: {
        description: {},
        lucidTablePath: {},
        ownership: {},
        datasetOwner: {},
        datasetOwnerBackups: {},
        datasetManager: {},
        datasetManagerBackups: {}
      }
    });

    mockDatasetInfoService = jasmine.createSpyObj('DatasetInfoService', ['currentReferentialId']);
    mockDatasetInfoService.currentReferentialId = of('test-id');

    mockAuthentificationService = jasmine.createSpyObj('AuthentificationService', ['fetchUserInfo', 'hasUserPermission']);
    mockAuthentificationService.fetchUserInfo.and.returnValue(of({
      name: 'test',
      sub: 'test-sub',
      is_sg_group_user: true,
      origin_network: 'test-network',
      user_authorization: 'test-authorization'
    }));
    mockAuthentificationService.hasUserPermission.and.returnValue(true);

    mockInformationService = jasmine.createSpyObj('InformationService', ['getReferentialInformation', 'saveReferentialInformation']);
    mockInformationService.getReferentialInformation.and.returnValue(of({
      body: {
        response: {
          referentialId: 'test-id',
          description: 'Test Description',
          lucidTablePath: 'Test Path',
          ownership: 'Test Ownership',
          datasetOwner: 'Test Owner',
          datasetOwnerBackups: ['owner1', 'owner2'],
          datasetManager: 'Test Manager',
          datasetManagerBackups: ['manager1', 'manager2']
        }
      }
    }));
    mockInformationService.saveReferentialInformation.and.returnValue(of({}));

    await TestBed.configureTestingModule({
      declarations: [ InformationTabComponent ],
      imports: [ ReactiveFormsModule ],
      providers: [
        { provide: FormBuilder, useValue: mockFormBuilder },
        { provide: DatasetInfoService, useValue: mockDatasetInfoService },
        { provide: AuthentificationService, useValue: mockAuthentificationService },
        { provide: InformationService, useValue: mockInformationService }
      ]
    })
    .compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(InformationTabComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should initialize form on init', () => {
    expect(component.formGroup).toBeTruthy();
    expect(mockFormBuilder.group).toHaveBeenCalled();
  });

  it('should check user access on init', () => {
    component.ngOnInit();
    expect(mockAuthentificationService.fetchUserInfo).toHaveBeenCalled();
    expect(mockAuthentificationService.hasUserPermission).toHaveBeenCalled();
    expect(component.isAuthenticated).toBeTrue();
  });

  it('should handle error during user access check', () => {
    mockAuthentificationService.fetchUserInfo.and.returnValue(throwError('error'));
    component.ngOnInit();
    expect(component.isAuthenticated).toBeTrue();
  });

  it('should load referential information on init', () => {
    component.ngOnInit();
    expect(mockInformationService.getReferentialInformation).toHaveBeenCalled();
    expect(component.referentialInfo).toEqual(jasmine.objectContaining({
      referentialId: 'test-id',
      description: 'Test Description',
      lucidTablePath: 'Test Path',
      ownership: 'Test Ownership',
      datasetOwner: 'Test Owner',
      datasetOwnerBackups: ['owner1', 'owner2'],
      datasetManager: 'Test Manager',
      datasetManagerBackups: ['manager1', 'manager2']
    }));
  });

  it('should handle error during referential information load', () => {
    mockInformationService.getReferentialInformation.and.returnValue(throwError('error'));
    component.ngOnInit();
    expect(component.showSpinner).toBeFalse();
  });

  it('should set form controls values from referential information', () => {
    component.ngOnInit();
    fixture.detectChanges();
    expect(component.formGroup.controls.description.value).toEqual('Test Description');
    expect(component.formGroup.controls.lucidTablePath.value).toEqual('Test Path');
    expect(component.formGroup.controls.ownership.value).toEqual('Test Ownership');
    expect(component.formGroup.controls.datasetOwner.value).toEqual('Test Owner');
    expect(component.formGroup.controls.datasetOwnerBackups.value).toEqual(['owner1', 'owner2']);
    expect(component.formGroup.controls.datasetManager.value).toEqual('Test Manager');
    expect(component.formGroup.controls.datasetManagerBackups.value).toEqual(['manager1', 'manager2']);
  });

  it('should submit form and update referential information', () => {
    component.editInfo();
    component.formGroup.setValue({
      description: 'New Description',
      lucidTablePath: 'New Path',
      ownership: 'New Ownership',
      datasetOwner: 'New Owner',
      datasetOwnerBackups: ['New Owner Backup'],
      datasetManager: 'New Manager',
      datasetManagerBackups: ['New Manager Backup']
    });

    component.submitInfo();
    expect(component.showSpinner).toBeTrue();
    expect(mockInformationService.saveReferentialInformation).toHaveBeenCalledWith(jasmine.objectContaining({
      referentialId: 'test-id',
      description: 'New Description',
      lucidTablePath: 'New Path',
      ownership: 'New Ownership',
      datasetOwner: 'New Owner',
      datasetOwnerBackups: ['New Owner Backup'],
      datasetManager: 'New Manager',
      datasetManagerBackups: ['New Manager Backup']
    }));
  });

  it('should cancel edit mode', () => {
    component.editInfo();
    component.cancelInfo();
    expect(component.isEditable).toBeFalse();
  });
});
