import { ComponentFixture, TestBed } from '@angular/core/testing';
import { BluebookPidV2Component } from './bluebook-pid-v2.component';
import { BluebookPidV2Service } from './bluebook-pid-v2.service';
import { FormBuilder, ReactiveFormsModule } from '@angular/forms';
import { of, throwError } from 'rxjs';
import * as moment from 'moment';
import * as FileSaver from 'file-saver';
import { HttpResponse } from '@angular/common/http';

describe('BluebookPidV2Component', () => {
  let component: BluebookPidV2Component;
  let fixture: ComponentFixture<BluebookPidV2Component>;
  let mockService: jasmine.SpyObj<BluebookPidV2Service>;

  beforeEach(async () => {
    const serviceSpy = jasmine.createSpyObj('BluebookPidV2Service', ['getBanks', 'generateReport']);

    await TestBed.configureTestingModule({
      declarations: [BluebookPidV2Component],
      providers: [
        FormBuilder,
        { provide: BluebookPidV2Service, useValue: serviceSpy }
      ],
      imports: [ReactiveFormsModule]
    }).compileComponents();

    fixture = TestBed.createComponent(BluebookPidV2Component);
    component = fixture.componentInstance;
    mockService = TestBed.inject(BluebookPidV2Service) as jasmine.SpyObj<BluebookPidV2Service>;

    fixture.detectChanges();
  });

  it('should initialize the form with bank, startDate, and endDate controls', () => {
    expect(component.form.contains('bank')).toBeTruthy();
    expect(component.form.contains('startDate')).toBeTruthy();
    expect(component.form.contains('endDate')).toBeTruthy();
  });

  it('should fetch banks on initialization', () => {
    const bankData = [
      { bic: 'BANK1', code: '001', name: 'Bank One' },
      { bic: 'BANK2', code: '002', name: 'Bank Two' }
    ];
    mockService.getBanks.and.returnValue(of(bankData));

    component.ngOnInit();
    fixture.detectChanges();

    expect(mockService.getBanks).toHaveBeenCalled();
    expect(component.banks.length).toBe(2);
    expect(component.banks[0].name).toBe('Bank One');
  });

  it('should generate report with correct formatted dates', () => {
    spyOn(FileSaver, 'saveAs');
    
    // Mock form values
    component.form.setValue({
      bank: { bic: 'BANK1', code: '001', name: 'Bank One' },
      startDate: '2024-01-15',
      endDate: '2024-01-31'
    });

    // Mock report service response
    const reportData = new HttpResponse({ body: new Blob(['report content']), headers: new Headers({'Content-Disposition': 'attachment; filename="report.pdf"'}) });
    mockService.generateReport.and.returnValue(of(reportData));

    component.generateReport('pdf');

    expect(mockService.generateReport).toHaveBeenCalledWith({
      biccode: 'BANK1',
      codetiank: '001',
      bankName: 'Bank One',
      startDate: moment('2024-01-15').startOf('month').format('YYYY-MM-DD'),
      endDate: moment('2024-01-31').endOf('month').format('YYYY-MM-DD')
    }, 'pdf');

    expect(FileSaver.saveAs).toHaveBeenCalled();
  });

  it('should handle report generation error and set error message', () => {
    spyOn(FileSaver, 'saveAs');

    component.form.setValue({
      bank: { bic: 'BANK1', code: '001', name: 'Bank One' },
      startDate: '2024-01-15',
      endDate: '2024-01-31'
    });

    const errorResponse = new HttpResponse({ status: 500, statusText: 'Internal Server Error' });
    mockService.generateReport.and.returnValue(throwError(errorResponse));

    component.generateReport('pdf');

    expect(component.$successHandler.value).toEqual({
      done: true,
      success: false,
      message: `Error while downloading report ${component.getDefaultFileName({
        biccode: 'BANK1',
        codetiank: '001',
        bankName: 'Bank One',
        startDate: moment('2024-01-15').startOf('month').format('YYYY-MM-DD'),
        endDate: moment('2024-01-31').endOf('month').format('YYYY-MM-DD')
      }, 'pdf')} (Internal Server Error)`
    });
  });
});
